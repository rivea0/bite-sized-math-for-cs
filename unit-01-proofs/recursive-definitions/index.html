
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="apple-touch-icon" sizes="180x180" href=/bite-sized-math-for-cs/public/apple-touch-icon.png>
    <link rel="icon" type="image/png" sizes="32x32" href=/bite-sized-math-for-cs/public/favicon-32x32.png>
    <link rel="icon" type="image/png" sizes="16x16" href=/bite-sized-math-for-cs/public/favicon-16x16.png>
    <link rel="manifest" href=/bite-sized-math-for-cs/public/site.webmanifest>
    <link rel="stylesheet" href=/bite-sized-math-for-cs/public/css/index.css>
    <link href="/public/css/prism-material-light.css" rel="stylesheet">
    <title>Recursive Definitions</title>
  </head>
  <body>
    <header class="title-header">
      <a href=/bite-sized-math-for-cs/>
        <h1 class="title">Bite-Sized Mathematics for Computer Science</h1></a>
        <h2 class="title-2">Notes on <a href="https://openlearninglibrary.mit.edu/courses/course-v1:OCW+6.042J+2T2019/course/">MIT's 6.042J</a></h2>
      <span class="author-name">Eda Eren</span>
    </header>
    <main>
      
      
      
      
      
      <details>
        <summary>Table of Contents</summary>
          <p>
            <a href="/">Introduction</a>
          </p>
          <p>
            <a href="/prerequisites-and-resources/">Prerequisites &amp; Resources</a>
          </p>
        <div>
          <p class="unit">Unit 1: Proofs</p>
            <p>
              <a href="/unit-01-proofs/introduction-to-proofs/">00. Introduction to Proofs</a>
            </p>
            <p>
              <a href="/unit-01-proofs/two-proof-methods/">01. (Two) Proof Methods</a>
            </p>
            <p>
              <a href="/unit-01-proofs/the-well-ordering-principle/">02. The Well Ordering Principle</a>
            </p>
            <p>
              <a href="/unit-01-proofs/logic-and-propositions/">03. Logic &amp; Propositions</a>
            </p>
            <p>
              <a href="/unit-01-proofs/quantifiers-and-predicate-logic/">04. Quantifiers and Predicate Logic</a>
            </p>
            <p>
              <a href="/unit-01-proofs/sets/">05. Sets</a>
            </p>
            <p>
              <a href="/unit-01-proofs/binary-relations/">06. Binary Relations</a>
            </p>
            <p>
              <a href="/unit-01-proofs/induction/">07. Induction</a>
            </p>
            <p>
              <a href="/unit-01-proofs/state-machines-invariants/">08. State Machines — Invariants</a>
            </p>
            <p class="active-page-link">
              <a href="/unit-01-proofs/recursive-definitions/">09. Recursive Definitions</a>
            </p>
            <p>
              <a href="/unit-01-proofs/infinite-sets/">10. Infinite Sets</a>
            </p>
        </div>
        <div>
          <p class="unit">Unit 2: Structures</p>
            <p>
              <a href="/unit-02-structures/gcds/">11. GCDs</a>
            </p>
            <p>
              <a href="/unit-02-structures/congruences/">12. Congruences</a>
            </p>
            <p>
              <a href="/unit-02-structures/eulers-theorem/">13. Euler&#39;s Theorem</a>
            </p>
            <p>
              <a href="/unit-02-structures/rsa-encryption/">14. RSA Encryption</a>
            </p>
            <p>
              <a href="/unit-02-structures/digraphs-walks-and-paths/">15. Digraphs: Walks and Paths</a>
            </p>
            <p>
              <a href="/unit-02-structures/directed-acyclic-graphs/">16. Directed Acyclic Graphs</a>
            </p>
            <p>
              <a href="/unit-02-structures/partial-orders-and-equivalence/">17. Partial Orders and Equivalence</a>
            </p>
            <p>
              <a href="/unit-02-structures/degrees-and-isomorphism/">18. Degrees &amp; Isomorphism</a>
            </p>
            <p>
              <a href="/unit-02-structures/coloring-and-connectivity/">19. Coloring &amp; Connectivity</a>
            </p>
            <p>
              <a href="/unit-02-structures/trees/">20. Trees</a>
            </p>
            <p>
              <a href="/unit-02-structures/stable-matching/">21. Stable Matching</a>
            </p>
        </div>
        <div>
          <p class="unit">Unit 3: Counting</p>
            <p>
              <a href="/unit-03-counting/sums-and-products/">22. Sums &amp; Products</a>
            </p>
            <p>
              <a href="/unit-03-counting/asymptotics/">23. Asymptotics</a>
            </p>
            <p>
              <a href="/unit-03-counting/counting-with-bijections/">24. Counting with Bijections</a>
            </p>
            <p>
              <a href="/unit-03-counting/repetitions-and-binomial-theorem/">25. Repetitions &amp; Binomial Theorem</a>
            </p>
            <p>
              <a href="/unit-03-counting/pigeonhole-principle-inclusion-exclusion/">26. Pigeonhole Principle, Inclusion-Exclusion</a>
            </p>
        </div>
        <div>
          <p class="unit">Unit 4: Probability</p>
            <p>
              <a href="/unit-04-probability/intro-to-discrete-probability/">27. Intro to Discrete Probability</a>
            </p>
            <p>
              <a href="/unit-04-probability/conditional-probability/">28. Conditional Probability</a>
            </p>
            <p>
              <a href="/unit-04-probability/independence-and-causality/">29. Independence &amp; Causality</a>
            </p>
            <p>
              <a href="/unit-04-probability/random-variables-density-functions/">30. Random Variables, Density Functions</a>
            </p>
            <p>
              <a href="/unit-04-probability/expectation/">31. Expectation</a>
            </p>
            <p>
              <a href="/unit-04-probability/deviation-markov-and-chebyshev-bounds/">32. Deviation: Markov &amp; Chebyshev Bounds</a>
            </p>
            <p>
              <a href="/unit-04-probability/sampling-and-confidence/">33. Sampling &amp; Confidence</a>
            </p>
            <p>
              <a href="/unit-04-probability/random-walks-and-pagerank/">34. Random Walks &amp; PageRank</a>
            </p>
        </div>
      </details>
      <div class="content">
      <h1>Recursive Definitions</h1>
<p>We can define a <mark>recursive definition</mark> as a way of constructing new data elements from previous ones, i.e., <em>defining something in terms of a simpler version of the same thing</em>.</p>
<p>There are two parts to it: <mark>base case(s)</mark> and <mark>constructor case(s)</mark>.</p>
<p>We can look at a binary string as an example. Usually, a binary string is defined as a sequence of <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span></eq>'s and <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span></eq>'s. An example of the string <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1011</mn></mrow><annotation encoding="application/x-tex">1011</annotation></semantics></math></span></eq> is the tuple <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mtext> </mtext><mn>0</mn><mo separator="true">,</mo><mtext> </mtext><mn>1</mn><mo separator="true">,</mo><mtext> </mtext><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1, \ 0, \ 1, \ 1)</annotation></semantics></math></span></eq>.<br>
But, with recursive definition, we can denote it as nested pairs, such as <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>〈</mtext><mn>1</mn><mo separator="true">,</mo><mtext>〈</mtext><mn>0</mn><mo separator="true">,</mo><mtext>〈</mtext><mn>1</mn><mo separator="true">,</mo><mtext>〈</mtext><mn>1</mn><mo separator="true">,</mo><mi>λ</mi><mtext>〉〉〉〉</mtext></mrow><annotation encoding="application/x-tex">\textlangle1, \textlangle0, \textlangle 1, \textlangle 1, \lambda \textrangle \textrangle \textrangle \textrangle</annotation></semantics></math></span></eq>, where <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span></eq> denotes the empty string — in this case, the base case.</p>
<p>A well-known example of a <em>recursive function</em> is the Fibonacci numbers:</p>
<p><eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(0) = 0</annotation></semantics></math></span></eq><br>
<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(1) = 1</annotation></semantics></math></span></eq><br>
<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mspace width="1em"/><mtext>for </mtext><mi>n</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">F(n) = F(n - 1) + F(n - 2) \quad  \text{for }n \geq 2</annotation></semantics></math></span></eq></p>
<hr>
<p>Let's now look at another example.<br>
Let's say we want to define a set of strings, <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></eq>, containing left and right brackets that match up: <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>⊆</mo><mo stretchy="false">{</mo><mtext> </mtext><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext> </mtext><mo stretchy="false">[</mo><mtext> </mtext><msup><mo stretchy="false">}</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">M \subseteq \{ \ ], \ [ \ \}^*</annotation></semantics></math></span></eq>.<br>
Okay, the notation looks funky, but it's a way to denote a set of finite strings, using an asterisk.</p>
<p>So, the base case is the empty string <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span></eq>, if we concatenate it to a string it doesn't change anything.</p>
<p>The constructor we have is this:</p>
<section><eqn><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>if </mtext><mi>s</mi><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo>∈</mo><mi>M</mi><mtext> then </mtext><mo stretchy="false">[</mo><mi>s</mi><mo stretchy="false">]</mo><mi>t</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\text{if }s, \ t \in M \text{ then } [s]t \in M</annotation></semantics></math></span></eqn></section><p>Okay, so what does it mean?</p>
<p>It says that if <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span></eq> and <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span></eq> are strings of brackets in <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></eq>, then the string <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo stretchy="false">]</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">[s]t</annotation></semantics></math></span></eq> is also in <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></eq>.</p>
<p>Let's see it in action.</p>
<p>We have the base case, that is, both <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span></eq> and <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span></eq> are empty. What we're left with is just a left and a right bracket: <strong>[ ]</strong>.<br>
If <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span></eq> is <strong>[ ]</strong>, and <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span></eq> is empty, we have <strong>[ [ ] ]</strong> as a result.<br>
If <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span></eq> is empty, and <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span></eq> is <strong>[ ]</strong>, we have <strong>[ ] [ ]</strong>.<br>
And, if both <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span></eq> and <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span></eq> are <strong>[ ]</strong>, we have <strong>[ [ ] ] [ ]</strong>.<br>
We can also imagine <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span></eq> being <strong>[ [ ] ]</strong>, and <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span></eq> being empty, then we have <strong>[ [ [ ] ] ]</strong>.</p>
<p>The cases we defined so far are these:</p>
<table>
<thead>
<tr>
<th>string</th>
<th>values</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[]</code></td>
<td><eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mi>λ</mi><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo>=</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">s = \lambda, \ t = \lambda</annotation></semantics></math></span></eq></td>
</tr>
<tr>
<td><code>[[]]</code></td>
<td><eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mo stretchy="false">[</mo><mtext> </mtext><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo>=</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">s = [ \ ], \ t = \lambda</annotation></semantics></math></span></eq></td>
</tr>
<tr>
<td><code>[][]</code></td>
<td><eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mi>λ</mi><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo>=</mo><mo stretchy="false">[</mo><mtext> </mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s = \lambda, \ t = [ \ ]</annotation></semantics></math></span></eq></td>
</tr>
<tr>
<td><code>[[]][]</code></td>
<td><eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mo stretchy="false">[</mo><mtext> </mtext><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo>=</mo><mo stretchy="false">[</mo><mtext> </mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s = [ \ ], \ t = [ \ ]</annotation></semantics></math></span></eq></td>
</tr>
<tr>
<td><code>[[[]]]</code></td>
<td><eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mo stretchy="false">[</mo><mtext> </mtext><mo stretchy="false">[</mo><mtext> </mtext><mo stretchy="false">]</mo><mtext> </mtext><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo>=</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">s = [ \ [ \ ] \ ], \ t = \lambda</annotation></semantics></math></span></eq></td>
</tr>
</tbody>
</table>
<p>Now, it can go on forever. But, how do we know that we will get matching brackets?</p>
<p>Well, one way we can look at it is this: if a string starts with <strong>]</strong>, then it is not going to be a <em>matching brackets string</em> because it has already lost starting with <strong>]</strong>, it has no pair.</p>
<p>We can assume that strings that start with <strong>]</strong> won't be in <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></eq>.</p>
<p>Now, one thing we know is that the only way to get elements in <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></eq> is by applying the constructor, or it's going to come from the base case itself. This is called the <mark>extremal clause</mark>, everything that's in <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></eq> is obtained from the base case and the constructor.<br>
Our base case for this matching brackets example is the empty sequence, so it definitely doesn't start with <strong>]</strong> because it doesn't even start.<br>
And, our constructor rule is <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo stretchy="false">]</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">[s]t</annotation></semantics></math></span></eq>, which also doesn't start with <strong>]</strong>, therefore a string starting with <strong>]</strong> is not going to be in <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></eq>.</p>
<hr>
<p><mark>Structural induction</mark> is <em>a method for proving that all the elements of a recursively defined data type have some property.</em></p>
<p>So, it is proving that a property <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x)</annotation></semantics></math></span></eq> holds for all <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></eq> in recursively defined set <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span></eq>. In order to do that, we need to prove that every element in each base case in <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span></eq> has the property (<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(b)</annotation></semantics></math></span></eq> for each base case <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span></eq>), also that each constructor holds the property (<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(c(x))</annotation></semantics></math></span></eq> for each constructor <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span></eq>) as well.</p>
<p>Let's see it using our matching brackets example.</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><em>Lemma:</em> Every string <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span></eq> in <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></eq> has the same number of <strong>]</strong>'s and <strong>[</strong>'s.</td>
</tr>
<tr>
<td style="text-align:left">Let <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">EQ</annotation></semantics></math></span></eq> be the set of strings with the same number of <strong>]</strong>'s and <strong>[</strong>'s.</td>
</tr>
<tr>
<td style="text-align:left">We assume <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>⊆</mo><mi>E</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">M \subseteq EQ</annotation></semantics></math></span></eq>.</td>
</tr>
<tr>
<td style="text-align:left">Induction hypothesis <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(s)</annotation></semantics></math></span></eq> is that <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>∈</mo><mi>E</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">s \in EQ</annotation></semantics></math></span></eq>.</td>
</tr>
<tr>
<td style="text-align:left">The base case is <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">s = \lambda</annotation></semantics></math></span></eq>, which means that <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></eq> is an empty set. The property holds because we have <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span></eq> left brackets and <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span></eq> right brackets, so we have an equal number of brackets. So, <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(\lambda)</annotation></semantics></math></span></eq> is true. ✅</td>
</tr>
<tr>
<td style="text-align:left">The constructor step was in the form of <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo stretchy="false">]</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">[s]t</annotation></semantics></math></span></eq>, but we're using the variable <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span></eq> to stand for the string, so let's use <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span></eq> instead. In this case, the constructor step is <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>r</mi><mo stretchy="false">]</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">[r]t</annotation></semantics></math></span></eq>.</td>
</tr>
<tr>
<td style="text-align:left">The number of <strong>]</strong>'s in <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span></eq> = <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>the number of </mtext><mo stretchy="false">]</mo><mtext>’s in </mtext><mi>r</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mtext>the number of </mtext><mo stretchy="false">]</mo><mtext>’s in </mtext><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(\text{the number of } ]\text{&#x27;s in }r) + (\text{the number of } ]\text{&#x27;s in }t) + 1</annotation></semantics></math></span></eq></td>
</tr>
<tr>
<td style="text-align:left">The number of <strong>[</strong>'s in <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span></eq> = <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>the number of </mtext><mo stretchy="false">[</mo><mtext>’s in </mtext><mi>r</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mtext>the number of </mtext><mo stretchy="false">[</mo><mtext>’s in </mtext><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(\text{the number of } [\text{&#x27;s in }r) + (\text{the number of } [\text{&#x27;s in }t) + 1</annotation></semantics></math></span></eq></td>
</tr>
<tr>
<td style="text-align:left">Because of <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(r)</annotation></semantics></math></span></eq>, the number of left and right brackets in <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span></eq> have to be equal.</td>
</tr>
<tr>
<td style="text-align:left">Likewise, because of <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(t)</annotation></semantics></math></span></eq>, the number of left and right brackets in <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span></eq> have to be equal as well.</td>
</tr>
<tr>
<td style="text-align:left">Then, <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mo stretchy="false">(</mo><mtext>the number of </mtext><mo stretchy="false">]</mo><mtext>’s in </mtext><mi>r</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mtext>the number of </mtext><mo stretchy="false">]</mo><mtext>’s in </mtext><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mo>=</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mo stretchy="false">(</mo><mtext>the number of </mtext><mo stretchy="false">[</mo><mtext>’s in </mtext><mi>r</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mtext>the number of </mtext><mo stretchy="false">[</mo><mtext>’s in </mtext><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo></mrow><annotation encoding="application/x-tex">\big((\text{the number of } ]\text{&#x27;s in }r) + (\text{the number of } ]\text{&#x27;s in }t) + 1\big) = \big((\text{the number of } [\text{&#x27;s in }r) + (\text{the number of } [\text{&#x27;s in }t) + 1\big)</annotation></semantics></math></span></eq></td>
</tr>
<tr>
<td style="text-align:left">Therefore, we realize that <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(s)</annotation></semantics></math></span></eq> is true: <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>the number of ]’s in </mtext><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mtext>the number of [’s in </mtext><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{the number of ]&#x27;s in } s) = (\text{the number of [&#x27;s in } s)</annotation></semantics></math></span></eq></td>
</tr>
<tr>
<td style="text-align:left">So, by structural induction, <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>s</mi><mo>∈</mo><mi>M</mi><mtext>  </mtext><mi>s</mi><mo>∈</mo><mi>E</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">\forall s \in M \ \ s \in EQ</annotation></semantics></math></span></eq>.</td>
</tr>
<tr>
<td style="text-align:left"><eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>⊆</mo><mi>E</mi><mi>Q</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mi mathvariant="normal">■</mi></mrow><annotation encoding="application/x-tex">M \subseteq EQ. \ \blacksquare</annotation></semantics></math></span></eq></td>
</tr>
</tbody>
</table>

      <hr class="ending">
          <ul class="links-nextprev"><li><a href="/unit-01-proofs/state-machines-invariants/">previous</a></li><li><a href="/unit-01-proofs/infinite-sets/">next</a></li>
          </ul> 
      </div>
    </main>
    <footer>
      <div>
        <h3>License</h3>
        <p>This work is licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="footer-links">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)</a>.</p>
      </div>
      <div>
        <h3>Open source</h3>
        <p>The source is on <a href="https://github.com/rivea0/bite-sized-math-for-cs" class="footer-links">GitHub</a>.</p>
      </div>
    </footer>
  </body>
</html>
